<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>JS - Call Apply</title>
</head>
<body>
	<h2>Метод forEach</h2>
<p>Давайте спробуємо самі створити функцію forEach, щоб детально розібратися як працює метод масива .forEach().</p>

<p>Завдання:
- створити функцію перебору елементів масива;
- у якості першого аргумента виступає масив, який необхідно перебрати;
- у якості другого аргумента виступає callback-функція, якою буде здійснено обробку кожного елемента масива.</p>

<p>В першу чергу створіть call-back функцію, що виводить в консоль квадрат переданого елемента та всі передані в функцію аргументи.</p>

<p>Функція може приймати 1, 2, або 3 аргумента: елемент, ітератор та сам масив.</p>

<h2>Метод sort</h2>
<p>Давайте спробуємо самі створити функцію Sort, щоб детально розібратися як працює метод масива .sort().</p>

<p>Завдання:
- створити функцію сортування елементів масива;
- у якості першого аргумента виступає масив, який необхідно відсортувати;
- у якості другого аргумента виступає callback-функція, якою буде здійснено обробку елементів масива попарно.</p>

<p>В першу чергу створіть 3 call-back функції, які сортують числа по зростанню, спаданню та в першу чергу виводять непарні, а потім - парні значення.</p>

<p>Функції повинні приймати по 2 аргумента, які будуть порівнювати між собою.</p>
<h2>Методи call та apply</h2>

<p>Методи call та apply застосовуються до будь-яких функцій чи методів.</p>

<p>Уявіть, що авто - це функція. Коли ви сідаєте за кермо та їдете - це прямий виклик функції.</p>

<p>Тепер уявіть, що в авто посадили робота. Робот - це метод call (чи apply), ви керуєте роботом, а робот керує автомобілем.</p>

<p>У такого способа керування автомобілем є свої недоліки та переваги.</p>

<h3>.call();</h3>
<p>Виклик здійснюється так:</p>

<p>func.call(context, arg1, arg2, arg3);
Даний метод задає функції контекст (this, батька).</p>

<p>Метод call підміняє контекст ("батька") для функції чи метода.</p>

<p>Ще один варіант практичного застосування:</p>

<p>var p = document.getElementsByTagName('p');
Хочемо перебрати всі пешки і щось з ними зробити.</p>

<p>У змінній p у нас не масив, а HTMLCollection, у нього немає метода forEach, тому доведеться використати цикл.</p>

<p>Або... скористатися методом call, викликавши forEach з прототипа чи іншого масива.</p>

<p>Це є можливим тому, що метод forEach не перевіряє - що ми йому підсовуємо як this: чи справжній масив, чи щось, що просто має елементи та властивість length.</p>

<h3>.apply();</h3>
<p>Метод .apply() дуже схожий на метод call, але зручніший для роботи з динамічною кількістю аргументів.</p>

<p>Тобто, ви можете передати всі аргументи у вигляді масива.</p>

<p>Це часто потрібно при виклику callback-функцій з довільною кількістю аргументів, детальніше розглянемо далі на методах max та min.</p>

<h2>Функції бібліотеки Math.max та Math.min</h2>
<p>Для кращого розуміння теми давайте самі створимо функції max та min, які є в бібліотеці Math.</p>

<p>Дані функції приймають довільну кількість аргументів (потрібно передбачити дії коли буде передано 0 або 1 аргумент та якщо є нечислові аргументи).</p>

<p>Серед усіх аргументів відбувається пошук найбільшого чи найменшого значення і повертається це значення.</p>

	<script src="script.js"></script>
</body>
</html>